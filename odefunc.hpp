
// Code generated by stanc v2.31.0
#include <stan/model/model_header.hpp>
namespace minimalODEExample-external_model_namespace {

struct odefunc_functor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_stan_scalar<T0__>,
                                stan::is_col_vector<T1__>,
                                stan::is_vt_not_complex<T1__>,
                                stan::is_stan_scalar<T2__>>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>, T2__>, -1, 1>
  operator()(const T0__& t, const T1__& y, const T2__& theta,
             std::ostream* pstream__) const;
};

struct odefunc_variadic2_functor__ {
  template <typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_stan_scalar<T0__>,
                                stan::is_col_vector<T1__>,
                                stan::is_vt_not_complex<T1__>,
                                stan::is_stan_scalar<T2__>>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>, T2__>, -1, 1>
  operator()(const T0__& t, const T1__& y, std::ostream* pstream__,
             const T2__& theta) const;
};

template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_stan_scalar<T2__>>* = nullptr>
  Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>, T2__>, -1, 1>
  odefunc(const T0__& t, const T1__& y_arg__, const T2__& theta,
          std::ostream* pstream__) {
    using local_scalar_t__ =
            stan::promote_args_t<T0__, stan::base_type_t<T1__>, T2__>;
    int current_statement__ = 0; 
    const auto& y = stan::math::to_ref(y_arg__);
    static constexpr bool propto__ = true;
    (void) propto__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      Eigen::Matrix<local_scalar_t__, -1, 1> dydt =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(2, DUMMY_VAR__);
      current_statement__ = 22;
      stan::model::assign(dydt,
        stan::model::rvalue(y, "y", stan::model::index_uni(2)),
        "assigning variable dydt", stan::model::index_uni(1));
      current_statement__ = 23;
      stan::model::assign(dydt,
        (-theta * stan::model::rvalue(y, "y", stan::model::index_uni(1))),
        "assigning variable dydt", stan::model::index_uni(2));
      current_statement__ = 24;
      return dydt;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }

template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_stan_scalar<T2__>>*>
Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>, T2__>, -1, 1>
odefunc_functor__::operator()(const T0__& t, const T1__& y,
                              const T2__& theta, std::ostream* pstream__) const
{
  return odefunc(t, y, theta, pstream__);
}


template <typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_stan_scalar<T2__>>*>
Eigen::Matrix<stan::promote_args_t<T0__, stan::base_type_t<T1__>, T2__>, -1, 1>
odefunc_variadic2_functor__::operator()(const T0__& t, const T1__& y,
                                        std::ostream* pstream__,
                                        const T2__& theta)  const
{
  return odefunc(t, y, theta, pstream__);
}

} //namespace
